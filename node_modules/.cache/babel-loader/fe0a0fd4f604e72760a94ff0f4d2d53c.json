{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\hpack\\\\Projects\\\\capstone\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\hpack\\\\Projects\\\\capstone\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar Resource = require('./Resource').Resource;\n\nvar PendingOperation = require('./PendingOperation').PendingOperation;\n\nvar now = require('./utils').now;\n\nvar duration = require('./utils').duration;\n\nvar checkOptionalTime = require('./utils').checkOptionalTime;\n\nvar delay = require('./utils').delay;\n\nvar reflect = require('./utils').reflect;\n\nvar tryPromise = require('./utils').tryPromise;\n\nvar Pool =\n/*#__PURE__*/\nfunction () {\n  function Pool(opt) {\n    _classCallCheck(this, Pool);\n\n    opt = opt || {};\n\n    if (!opt.create) {\n      throw new Error('Tarn: opt.create function most be provided');\n    }\n\n    if (!opt.destroy) {\n      throw new Error('Tarn: opt.destroy function most be provided');\n    }\n\n    if (typeof opt.min !== 'number' || opt.min < 0 || opt.min !== Math.round(opt.min)) {\n      throw new Error('Tarn: opt.min must be an integer >= 0');\n    }\n\n    if (typeof opt.max !== 'number' || opt.max <= 0 || opt.max !== Math.round(opt.max)) {\n      throw new Error('Tarn: opt.max must be an integer > 0');\n    }\n\n    if (opt.min > opt.max) {\n      throw new Error('Tarn: opt.max is smaller than opt.min');\n    }\n\n    if (!checkOptionalTime(opt.acquireTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.acquireTimeoutMillis ' + JSON.stringify(opt.acquireTimeoutMillis));\n    }\n\n    if (!checkOptionalTime(opt.createTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.createTimeoutMillis ' + JSON.stringify(opt.createTimeoutMillis));\n    }\n\n    if (!checkOptionalTime(opt.idleTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.idleTimeoutMillis ' + JSON.stringify(opt.idleTimeoutMillis));\n    }\n\n    if (!checkOptionalTime(opt.reapIntervalMillis)) {\n      throw new Error('Tarn: invalid opt.reapIntervalMillis ' + JSON.stringify(opt.reapIntervalMillis));\n    }\n\n    if (!checkOptionalTime(opt.createRetryIntervalMillis)) {\n      throw new Error('Tarn: invalid opt.createRetryIntervalMillis ' + JSON.stringify(opt.createRetryIntervalMillis));\n    }\n\n    this.creator = opt.create;\n    this.destroyer = opt.destroy;\n    this.validate = typeof opt.validate === 'function' ? opt.validate : function () {\n      return true;\n    };\n\n    this.log = opt.log || function () {};\n\n    this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 30000;\n    this.createTimeoutMillis = opt.createTimeoutMillis || 30000;\n    this.idleTimeoutMillis = opt.idleTimeoutMillis || 30000;\n    this.reapIntervalMillis = opt.reapIntervalMillis || 1000;\n    this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;\n    this.propagateCreateError = !!opt.propagateCreateError;\n    this.min = opt.min;\n    this.max = opt.max;\n    this.used = [];\n    this.free = [];\n    this.pendingCreates = [];\n    this.pendingAcquires = [];\n    this.destroyed = false;\n    this.interval = null;\n  }\n\n  _createClass(Pool, [{\n    key: \"numUsed\",\n    value: function numUsed() {\n      return this.used.length;\n    }\n  }, {\n    key: \"numFree\",\n    value: function numFree() {\n      return this.free.length;\n    }\n  }, {\n    key: \"numPendingAcquires\",\n    value: function numPendingAcquires() {\n      return this.pendingAcquires.length;\n    }\n  }, {\n    key: \"numPendingCreates\",\n    value: function numPendingCreates() {\n      return this.pendingCreates.length;\n    }\n  }, {\n    key: \"acquire\",\n    value: function acquire() {\n      var _this = this;\n\n      var pendingAcquire = new PendingOperation(this.acquireTimeoutMillis);\n      this.pendingAcquires.push(pendingAcquire); // If the acquire fails for whatever reason\n      // remove it from the pending queue.\n\n      pendingAcquire.promise = pendingAcquire.promise.catch(function (err) {\n        remove(_this.pendingAcquires, pendingAcquire);\n        return Promise.reject(err);\n      });\n\n      this._tryAcquireOrCreate();\n\n      return pendingAcquire;\n    }\n  }, {\n    key: \"release\",\n    value: function release(resource) {\n      for (var i = 0, l = this.used.length; i < l; ++i) {\n        var used = this.used[i];\n\n        if (used.resource === resource) {\n          this.used.splice(i, 1);\n          this.free.push(used.resolve());\n\n          this._tryAcquireOrCreate();\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return [this.numFree(), this.numUsed(), this.numPendingAcquires(), this.numPendingCreates()].reduce(function (total, value) {\n        return total + value;\n      }) === 0;\n    }\n  }, {\n    key: \"check\",\n    value: function check() {\n      var _this2 = this;\n\n      var timestamp = now();\n      var newFree = [];\n      var minKeep = this.min - this.used.length;\n      var maxDestroy = this.free.length - minKeep;\n      var numDestroyed = 0;\n      this.free.forEach(function (free) {\n        if (duration(timestamp, free.timestamp) > _this2.idleTimeoutMillis && numDestroyed < maxDestroy) {\n          numDestroyed++;\n\n          _this2._destroy(free.resource);\n        } else {\n          newFree.push(free);\n        }\n      });\n      this.free = newFree; //Pool is completely empty, stop reaping.\n      //Next .acquire will start reaping interval again.\n\n      if (this.isEmpty()) {\n        this._stopReaping();\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this3 = this;\n\n      this._stopReaping();\n\n      this.destroyed = true; // First wait for all the pending creates get ready.\n\n      return reflect(Promise.all(this.pendingCreates.map(function (create) {\n        return reflect(create.promise);\n      })).then(function () {\n        // Wait for all the used resources to be freed.\n        return Promise.all(_this3.used.map(function (used) {\n          return reflect(used.promise);\n        }));\n      }).then(function () {\n        // Abort all pending acquires.\n        return Promise.all(_this3.pendingAcquires.map(function (acquire) {\n          acquire.abort();\n          return reflect(acquire.promise);\n        }));\n      }).then(function () {\n        // Now we can destroy all the freed resources.\n        _this3.free.forEach(function (free) {\n          return _this3._destroy(free.resource);\n        });\n\n        _this3.free = [];\n        _this3.pendingAcquires = [];\n      }));\n    }\n  }, {\n    key: \"_tryAcquireOrCreate\",\n    value: function _tryAcquireOrCreate() {\n      if (this.destroyed) {\n        return;\n      }\n\n      if (this._hasFreeResources()) {\n        this._doAcquire();\n      } else if (this._shouldCreateMoreResources()) {\n        this._doCreate();\n      }\n    }\n  }, {\n    key: \"_hasFreeResources\",\n    value: function _hasFreeResources() {\n      return this.free.length > 0;\n    }\n  }, {\n    key: \"_doAcquire\",\n    value: function _doAcquire() {\n      var didDestroyResources = false;\n\n      while (this._canAcquire()) {\n        var pendingAcquire = this.pendingAcquires[0];\n        var free = this.free[this.free.length - 1];\n\n        if (!this._validateResource(free.resource)) {\n          this.free.pop();\n\n          this._destroy(free.resource);\n\n          didDestroyResources = true;\n          continue;\n        }\n\n        this.pendingAcquires.shift();\n        this.free.pop();\n        this.used.push(free.resolve()); //At least one active resource, start reaping\n\n        this._startReaping();\n\n        pendingAcquire.resolve(free.resource);\n      } // If we destroyed invalid resources, we may need to create new ones.\n\n\n      if (didDestroyResources) {\n        this._tryAcquireOrCreate();\n      }\n    }\n  }, {\n    key: \"_canAcquire\",\n    value: function _canAcquire() {\n      return this.free.length > 0 && this.pendingAcquires.length > 0;\n    }\n  }, {\n    key: \"_validateResource\",\n    value: function _validateResource(resource) {\n      try {\n        return !!this.validate(resource);\n      } catch (err) {\n        // There's nothing we can do here but log the error. This would otherwise\n        // leak out as an unhandled exception.\n        this.log('Tarn: resource validator threw an exception ' + err.stack, 'warn');\n        return false;\n      }\n    }\n  }, {\n    key: \"_shouldCreateMoreResources\",\n    value: function _shouldCreateMoreResources() {\n      return this.used.length + this.pendingCreates.length < this.max && this.pendingCreates.length < this.pendingAcquires.length;\n    }\n  }, {\n    key: \"_doCreate\",\n    value: function _doCreate() {\n      var _this4 = this;\n\n      var pendingAcquiresBeforeCreate = this.pendingAcquires.slice();\n\n      var pendingCreate = this._create();\n\n      pendingCreate.promise.then(function () {\n        // Not returned on purpose.\n        _this4._tryAcquireOrCreate();\n      }).catch(function (err) {\n        if (_this4.propagateCreateError && _this4.pendingAcquires.length !== 0) {\n          // If propagateCreateError is true, we don't retry the create\n          // but reject the first pending acquire immediately. Intentionally\n          // use `this.pendingAcquires` instead of `pendingAcquiresBeforeCreate`\n          // in case some acquires in pendingAcquiresBeforeCreate have already\n          // been resolved.\n          _this4.pendingAcquires[0].reject(err);\n        } // Save the create error to all pending acquires so that we can use it\n        // as the error to reject the acquire if it times out.\n\n\n        pendingAcquiresBeforeCreate.forEach(function (pendingAcquire) {\n          pendingAcquire.possibleTimeoutCause = err;\n        }); // Not returned on purpose.\n\n        delay(_this4.createRetryIntervalMillis).then(function () {\n          return _this4._tryAcquireOrCreate();\n        });\n      });\n    }\n  }, {\n    key: \"_create\",\n    value: function _create() {\n      var _this5 = this;\n\n      var pendingCreate = new PendingOperation(this.createTimeoutMillis);\n      this.pendingCreates.push(pendingCreate);\n      callbackOrPromise(this.creator).then(function (resource) {\n        remove(_this5.pendingCreates, pendingCreate);\n\n        _this5.free.push(new Resource(resource));\n\n        pendingCreate.resolve(resource);\n      }).catch(function (err) {\n        remove(_this5.pendingCreates, pendingCreate);\n        pendingCreate.reject(err);\n      });\n      return pendingCreate;\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy(resource) {\n      try {\n        this.destroyer(resource);\n      } catch (err) {\n        // There's nothing we can do here but log the error. This would otherwise\n        // leak out as an unhandled exception.\n        this.log('Tarn: resource destroyer threw an exception ' + err.stack, 'warn');\n      }\n    }\n  }, {\n    key: \"_startReaping\",\n    value: function _startReaping() {\n      var _this6 = this;\n\n      if (!this.interval) {\n        this.interval = setInterval(function () {\n          return _this6.check();\n        }, this.reapIntervalMillis);\n      }\n    }\n  }, {\n    key: \"_stopReaping\",\n    value: function _stopReaping() {\n      clearInterval(this.interval);\n      this.interval = null;\n    }\n  }]);\n\n  return Pool;\n}();\n\nfunction remove(arr, item) {\n  var idx = arr.indexOf(item);\n\n  if (idx === -1) {\n    return false;\n  } else {\n    arr.splice(idx, 1);\n    return true;\n  }\n}\n\nfunction callbackOrPromise(func) {\n  return new Promise(function (resolve, reject) {\n    var callback = function callback(err, resource) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(resource);\n      }\n    };\n\n    tryPromise(function () {\n      return func(callback);\n    }).then(function (res) {\n      // If the result is falsy, we assume that the callback will\n      // be called instead of interpreting the falsy value as a\n      // result value.\n      if (res) {\n        resolve(res);\n      }\n    }).catch(function (err) {\n      reject(err);\n    });\n  });\n}\n\nmodule.exports = {\n  Pool: Pool\n};","map":null,"metadata":{},"sourceType":"script"}